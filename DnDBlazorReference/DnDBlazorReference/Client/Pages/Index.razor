@page "/"

@using System
@using DnDBlazorReference.Shared
@using DnDBlazorReference.Shared.Models
@using System.Text.Json
@using System.Text.Json.Serialization
@using Tewr.Blazor.FileReader
@inject HttpClient Http
@inject IFileReaderService FileReaderService

<!--
<SurveyPrompt Title="How is Blazor working for you?" />
-->

<h1>Monsters</h1>

<p>This component demonstrates fetching data from the server.</p>

@if (!string.IsNullOrEmpty(errorString))
{
    <p><b>Error:</b> @errorString</p>
}
else if (monsterJson == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <button @onclick="ProcessJsonOutput">Process Json</button>

    <table class="table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Source</th>
                <th>Other Sources</th>
                <th>Creature Type</th>
                <th>AC</th>
                <th>Size</th>
                <th>Health</th>
                <th>Strength</th>
                <th>Dexterity</th>
                <th>Constitution</th>
                <th>Intelligence</th>
                <th>Wisdom</th>
                <th>Charisma</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var monsterItem in monsterJson.monster)
            {
                <tr>
                    <td>@monsterItem.Name</td>
                    <td>@monsterItem.Source</td>
                    <td>
                        @if (monsterItem.OtherSources != null)
                        {
                            @monsterItem.OtherSources.Count
                            @*@(string.Join(", ", monsterItem.OtherSources))*@
                        }
                    </td>
                    <td>
                        @monsterItem.CreatureType
                    </td>
                    <td>
                        @if (monsterItem.ArmorClass != null)
                        {
                            @(string.Join(", ", monsterItem.ArmorClass))
                        }
                    </td>
                    <td>@monsterItem.Size</td>
                    <td>@monsterItem.Health</td>
                    <td>@monsterItem.Strength</td>
                    <td>@monsterItem.Dexterity</td>
                    <td>@monsterItem.Constitution</td>
                    <td>@monsterItem.Intelligence</td>
                    <td>@monsterItem.Wisdom</td>
                    <td>@monsterItem.Charisma</td>
                </tr>
            }
        </tbody>
    </table>

    <div>
        @outputJson
    </div>
    <div>
        <input type="file" @ref="_input" @onchange="FileChanged" accept=".json" />
        <div>
            Is Processing: @isProcessing
            @if (isProcessing)
            {
                <div>
                    @($"{readSize/(double)totalSize:P}")
                </div>
            }
        </div>
        @if (false && fileOutput != null)
        {
            <div>
                @String.Join("", fileOutput)
            </div>
        }
    </div>
}

@code {
    public class Monster5eToolsJson
    {
        public Monster5eTools[] monster { get; set; }
    }

    private Monster5eToolsJson monsterJson;

    private string errorString = string.Empty;

    private string outputJson = string.Empty;

    private ElementReference _input;

    private List<string> fileOutput;

    private bool isProcessing;

    private long readSize = 0;
    private long totalSize = 0;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            errorString = string.Empty;
            var options = new JsonSerializerOptions
            {
                ReadCommentHandling = JsonCommentHandling.Skip,
                AllowTrailingCommas = true
            };

            monsterJson = await Http.GetFromJsonAsync<Monster5eToolsJson>("sample-data/beastiary-mm.json", options);
        }
        catch (Exception e)
        {
            // do nothing
            errorString = e.Message;
        }
    }

    public async void FileChanged()
    {
        var options = new JsonSerializerOptions
        {
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };

        foreach (var file in await FileReaderService.CreateReference(_input).EnumerateFilesAsync())
        {
            if (file == null)
            {
                continue;
            }

            isProcessing = true;

            var fileInfo = await file.ReadFileInfoAsync();

            fileOutput = new List<string>();
            const int byteBufferSize = 1024;
            byte[] buffer = new byte[byteBufferSize];
            using (var reader = await file.OpenReadAsync())
            {
                try
                {
                    monsterJson = await JsonSerializer.DeserializeAsync<Monster5eToolsJson>(reader, options);
                }
                catch (Exception e)
                {
                    // do nothing
                    errorString = e.Message;
                }
            }

            isProcessing = false;
        }

        StateHasChanged();
    }

    public void ProcessJsonOutput()
    {
        outputJson = "Trying to process";
        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
        };

        outputJson = JsonSerializer.Serialize(monsterJson, options);
    }
}
